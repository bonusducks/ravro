
mod schema_model {
    extern crate serde;

    //use serde::json::Value;

    // Because of the way Serde does JSON ser/des for enum types,
    // I can't use an actual enumerated type as the type marker
    // for the "simple" Avro type. I'm going to have to use a 
    // string and do manual checking/conversion afterwards. Gah.

    #[derive(Debug, Clone, PartialEq)]
    pub enum PrimitiveTypeEnum {
        Null,
        Boolean,
        Int,
        Long,
        Float,
        Double,
        Bytes,
        String,
    }

    impl PrimitiveTypeEnum {
        pub fn to_str(&self) -> &'static str {
            match *self {
                PrimitiveTypeEnum::Null    => "null",
                PrimitiveTypeEnum::Boolean => "boolean",
                PrimitiveTypeEnum::Int     => "int",
                PrimitiveTypeEnum::Long    => "long",
                PrimitiveTypeEnum::Float   => "float",
                PrimitiveTypeEnum::Double  => "double",
                PrimitiveTypeEnum::Bytes   => "bytes",
                PrimitiveTypeEnum::String  => "string",
            }
        }

        pub fn from_str(raw_type : &str) -> Option<PrimitiveTypeEnum> {
            match raw_type {
                "null"      => Some(PrimitiveTypeEnum::Null),
                "boolean"   => Some(PrimitiveTypeEnum::Boolean),
                "int"       => Some(PrimitiveTypeEnum::Int),
                "long"      => Some(PrimitiveTypeEnum::Long),
                "float"     => Some(PrimitiveTypeEnum::Float),
                "double"    => Some(PrimitiveTypeEnum::Double),
                "bytes"     => Some(PrimitiveTypeEnum::Bytes),
                "string"    => Some(PrimitiveTypeEnum::String),
                _           => None
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq)]
    pub struct Schema {
        #[serde(rename="type")]
        type_name: String,
        name: Option<String>,   // required for type = record|enum|fixed
        namespace: Option<String>,
        doc: Option<String>,
        aliases: Vec<String>,
        fields: Vec<Field>,
    }

    // For now, this really only supports Primitive Types.
    impl Schema {
        pub fn is_valid(&self) -> Result<(), &'static str> {
            let tn = self.type_name.as_ref();
            match tn {
                "record"    => Ok(()),
                _           =>
                    match PrimitiveTypeEnum::from_str(&tn) {
                        Some(..)    => Ok(()),
                        None        => Err("Not a valid simple type"),
                    },
            }
            
        }

        pub fn new(type_str: &str) -> Result<Schema, &'static str> {
            let basic_schema = Schema {
                type_name: type_str.to_string(),
                name: None,
                namespace: None,
                doc: None,
                /*
                aliases: Vec::with_capacity(1),
                fields: Vec::with_capacity(1),
                */
                aliases: Vec::new(),
                fields: Vec::new(),
            };
            try!(basic_schema.is_valid());
            Ok(basic_schema)
        }

        pub fn new_rec(name: &str, fields: &Vec<Field>) -> Result<Schema, &'static str> {
            let rec_schema = Schema {
                type_name: "record".to_string(),
                name: Some(name.to_string()),
                namespace: None,
                doc: None,
                aliases: Vec::new(),
                fields: fields.to_vec(),
            };
            try!(rec_schema.is_valid());
            Ok(rec_schema)
        }

        pub fn new_rec_full(name: &str,
                            fields: &Vec<Field>,
                            namespace: &str,
                            doc: &str,
                            aliases: &Vec<String>) -> Result<Schema, &'static str> {
            let rec_schema = Schema {
                type_name: "record".to_string(),
                name: Some(name.to_string()),
                namespace: if namespace.is_empty() { None } else { Some(namespace.to_string()) },
                doc: if doc.is_empty() { None } else { Some(doc.to_string()) },
                aliases: aliases.to_vec(),
                fields: fields.to_vec(),
            };
            try!(rec_schema.is_valid());
            Ok(rec_schema)
        }
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
    pub enum FieldType {
        Object,
        Name,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub enum SortOrder {
        Ascending,
        Descending,
        Ignore,
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
    pub struct Field {
        name: String,
        doc: Option<String>, 
        #[serde(rename="type")]
        field_type: FieldType,
        //default: Option<serde::json::Value>,    // Punt. 
        default: Option<String>,    // Punt. 
        order: Option<SortOrder>,
        aliases: Option<Vec<String>>,
    }
} // end model mod
