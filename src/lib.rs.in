
mod schema_model {
    use regex::Regex;
    use serde::json::Value;
    use serde::json::builder::ObjectBuilder;

    pub type PrimitiveType = String;

    #[derive(Clone, PartialEq, Debug)]
    pub enum Schema {
        Null,
        String(String),
        Array(Vec<Schema>),
        Object(Value)
    }

    impl Schema {
        pub fn is_primitive(&self) -> bool {
            match *self {
                Schema::String(ref s) => {
                    match s.as_ref() {
                        "null" | "boolean" | "int" | "long" | "float" | "double" | "bytes" | "string" => true,
                        _ => false,
                    }
                },
                _ => false,
            }
        }

        pub fn is_array(&self) -> bool {
            match *self {
                Schema::Array(_)   => true,
                _ => false,
            }
        }

        pub fn is_object(&self) -> bool {
            match *self {
                Schema::Object(_) => true,
                _ => false,
            }
        }

        /// Returns a new Schema representing the instance as a Schema::Object.
        /// If it's already a Schema::Object instance, a copy is returned.
        pub fn as_object(&self) -> Option<Schema> {
            match *self {
                Schema::Object(_) => Some(self.clone()),
                Schema::String(ref s) => {
                    let value = ObjectBuilder::new()
                        .insert("type".to_string(), s.clone())
                        .unwrap();
                    Some(Schema::Object(value))
                }
                _ => None
            }
        }

        pub fn is_null(&self) -> bool {
            match *self {
                Schema::Null => true,
                _ => false,
            }
        }
    }

    //use serde::json::Value;

    // Because of the way Serde does JSON ser/des for enum types,
    // I can't use an actual enumerated type as the type marker
    // for the "simple" Avro type. I'm going to have to use a 
    // string and do manual checking/conversion afterwards. Gah.

    #[derive(Debug, Clone, PartialEq)]
    pub enum PrimitiveTypeEnum {
        Null,
        Boolean,
        Int,
        Long,
        Float,
        Double,
        Bytes,
        String,
    }

    impl PrimitiveTypeEnum {
        pub fn to_str(&self) -> &'static str {
            match *self {
                PrimitiveTypeEnum::Null    => "null",
                PrimitiveTypeEnum::Boolean => "boolean",
                PrimitiveTypeEnum::Int     => "int",
                PrimitiveTypeEnum::Long    => "long",
                PrimitiveTypeEnum::Float   => "float",
                PrimitiveTypeEnum::Double  => "double",
                PrimitiveTypeEnum::Bytes   => "bytes",
                PrimitiveTypeEnum::String  => "string",
            }
        }

        pub fn from_str(raw_type : &str) -> Option<PrimitiveTypeEnum> {
            match raw_type {
                "null"      => Some(PrimitiveTypeEnum::Null),
                "boolean"   => Some(PrimitiveTypeEnum::Boolean),
                "int"       => Some(PrimitiveTypeEnum::Int),
                "long"      => Some(PrimitiveTypeEnum::Long),
                "float"     => Some(PrimitiveTypeEnum::Float),
                "double"    => Some(PrimitiveTypeEnum::Double),
                "bytes"     => Some(PrimitiveTypeEnum::Bytes),
                "string"    => Some(PrimitiveTypeEnum::String),
                _           => None
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
    pub struct SchemaOld {
        #[serde(rename="type")]
        type_name: String,
        name: Option<String>,   // required for type = record|enum|fixed
        namespace: Option<String>,
        doc: Option<String>,
        aliases: Vec<String>,
        fields: Vec<Field>,
    }

    // For now, this really only supports Primitive Types.
    impl SchemaOld {
        pub fn is_valid(&self) -> Result<(), &'static str> {
            let tn = self.type_name.as_ref();
            match tn {
                "record"    => self.is_rec_valid(),
                "enum"      => self.is_enum_valid(),
                _           =>
                    match PrimitiveTypeEnum::from_str(&tn) {
                        Some(..)    => Ok(()),
                        None        => Err("Not a valid primitive type"),
                    },
            }
            
        }

        fn is_rec_valid(&self) -> Result<(), &'static str> {
            match self.name {
                Some(ref n) => {
                    if n.is_empty() { return Err("Records must have a name"); }
                    // try to get the SchemaOld's fullname to verify it's valid.
                    let fn_result = self.fullname();
                    if fn_result.is_err() { return Err(fn_result.unwrap_err()); }
                },
                None    => return Err("Records must have a name"),
            }

            Ok(())
        }

        fn is_enum_valid(&self) -> Result<(), &'static str> {
            match self.name {
                Some(ref n) => {
                    if n.is_empty() { return Err("Enums must have a name"); }
                    // try to get the SchemaOld's fullname to verify it's valid.
                    let fn_result = self.fullname();
                    if fn_result.is_err() { return Err(fn_result.unwrap_err()); }
                },
                None    => return Err("Enums must have a name"),
            }

            // TODO - there must be at lest one symbol.

            Ok(())
        }

        pub fn new(type_str: &str) -> Result<SchemaOld, &'static str> {
            let basic_schema = SchemaOld {
                type_name: type_str.to_string(),
                name: None,
                namespace: None,
                doc: None,
                aliases: Vec::new(),
                fields: Vec::new(),
            };
            try!(basic_schema.is_valid());
            Ok(basic_schema)
        }

        pub fn new_rec(name: &str, fields: &Vec<Field>) -> Result<SchemaOld, &'static str> {
            let rec_schema = SchemaOld {
                type_name: "record".to_string(),
                name: Some(name.to_string()),
                namespace: None,
                doc: None,
                aliases: Vec::new(),
                fields: fields.to_vec(),
            };
            try!(rec_schema.is_valid());
            Ok(rec_schema)
        }

        pub fn new_rec_full(name: &str,
                            fields: &Vec<Field>,
                            namespace: &str,
                            doc: &str,
                            aliases: &Vec<String>) -> Result<SchemaOld, &'static str> {
            let rec_schema = SchemaOld {
                type_name: "record".to_string(),
                name: Some(name.to_string()),
                namespace: if namespace.is_empty() { None } else { Some(namespace.to_string()) },
                doc: if doc.is_empty() { None } else { Some(doc.to_string()) },
                aliases: aliases.to_vec(),
                fields: fields.to_vec(),
            };
            try!(rec_schema.is_valid());
            Ok(rec_schema)
        }

        /*
        pub fn new_enum(name: &str, symbols: &Vec<&str>) -> Result<SchemaOld, &'static str> {
            let enum_schema = SchemaOld {
                type_name: "enum".to_string(),
                name: Some(name.to_string()),
                namespace: None,
                doc: None,
                aliases: Vec::new(),
                fields: Vec::new(),
            };
            try!(enum_schema.is_valid());
            Ok(enum_schema)
        }
        */

        pub fn fullname(&self) -> Result<String, &'static str> {
            static NOT_WELL_FORMED_ERR : &'static str = "Name is not well formed";
            let mut full_name = String::new();
            let mut name: &str;
            let mut namespace_str: &str = "";
            let mut ignore_ns = false;

            match self.name {
                Some(ref n)     => name = &n,
                None            => name = "",
            }

            match self.type_name.as_ref() {
                "record" | "enum"  => {
                    // Sanity check. Constructors should have prevented this.
                    if name.is_empty() { return Err("Name cannot be empty"); }

                    let name_segment_re = Regex::new(r#"^[A-Za-z_][A-Za-z0-9_]*$"#).unwrap();
                    
                    // Edge cases
                    if name.starts_with(".") || name.ends_with(".") {
                        return Err(NOT_WELL_FORMED_ERR);
                    }
                    
                    // If the name has any periods in it, the name is the fullname and the
                    // namespace attribute is ignored.
                    if name.contains(".") {
                        ignore_ns = true;   // periods in the name attribute override the namespace attribute
                        namespace_str = "";

                        let ns_vec : Vec<&str> = name.split('.').collect();
                        for ns_elem in ns_vec {
                            if !name_segment_re.is_match(ns_elem) { return Err(NOT_WELL_FORMED_ERR); }
                        }
                    } else {
                        if !name_segment_re.is_match(name) { return Err(NOT_WELL_FORMED_ERR); }

                        // OK, now lets check the namespace.
                        match self.namespace {
                            Some(ref ns_string) => {
                                let ns = &ns_string;

                                // Edge casing again.
                                if ns.starts_with(".") || ns.ends_with(".") { return Err(NOT_WELL_FORMED_ERR); }
                                
                                let ns_vec : Vec<&str> = ns.split('.').collect();
                                for ns_elem in ns_vec {
                                    if !name_segment_re.is_match(ns_elem) { return Err(NOT_WELL_FORMED_ERR); }
                                }

                                namespace_str = ns;
                            },
                            None => {
                                ignore_ns = true;
                                namespace_str = "";
                            },
                        }
                    }
                }

                _  => {
                    // The spec is a little vague on what to do here. Primitive types don't exactly have names,
                    // but they kinda do, too. Namely, their type names.
                    name = self.type_name.as_ref();
                    ignore_ns = true;
                }
            }

            if !ignore_ns && !namespace_str.is_empty() {
                full_name.push_str(namespace_str);
                full_name.push_str(".");
            }            

            full_name.push_str(&name);

            Ok(full_name)
        }
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
    pub struct Field {
        name: String,
        #[serde(rename="type")]
        field_type: Value,          // Gah, I'm going to have to do this by hand.
        default: Option<Value>,    // punt. 
        doc: Option<String>, 
        order: Option<String>,      // This should be an enum, but the serde JSON serialization does not good things 
        aliases: Option<Vec<String>>,
    }

    impl Field {
        pub fn new(name: &str, primitive_type: &str) -> Result<Field, &'static str> {
            let type_value = Value::String(primitive_type.to_string());

            let f = Field {
                name: name.to_string(),
                field_type: type_value,
                default: None,
                doc: None,
                order: None,
                aliases: None,
            };
            Ok(f)
        }

        pub fn new_full(name: &str, 
                        primitive_type: &str,
                        default: &Option<Value>,
                        doc: &str,
                        order: &str,
                        aliases: &Vec<String>) -> Result<Field, &'static str> {
            let type_value = Value::String(primitive_type.to_string());
            let f = Field {
                name: name.to_string(),
                field_type: type_value,
                default: default.clone(),
                doc: if doc.is_empty() { None } else { Some(doc.to_string()) },
                order: if order.is_empty() { None } else { Some(order.to_string()) },
                aliases: if aliases.len() == 0 { None } else { Some(aliases.to_vec()) },
            };
            Ok(f)
        }
    }
} // end model mod
