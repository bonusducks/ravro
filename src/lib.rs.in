
mod schema_model {
    extern crate serde;

    use serde::json::Value;

    // Because of the way Serde does JSON ser/des for enum types,
    // I can't use an actual enumerated type as the type marker
    // for the "simple" Avro type. I'm going to have to use a 
    // string and do manual checking/conversion afterwards. Gah.

    #[derive(Debug, Clone, PartialEq)]
    pub enum PrimitiveTypeEnum {
        Null,
        Boolean,
        Int,
        Long,
        Float,
        Double,
        Bytes,
        String,
    }

    impl PrimitiveTypeEnum {
        pub fn to_string(&self) -> String {
            match *self {
                PrimitiveTypeEnum::Null    => "null".to_string(),
                PrimitiveTypeEnum::Boolean => "boolean".to_string(),
                PrimitiveTypeEnum::Int     => "int".to_string(),
                PrimitiveTypeEnum::Long    => "long".to_string(),
                PrimitiveTypeEnum::Float   => "float".to_string(),
                PrimitiveTypeEnum::Double  => "double".to_string(),
                PrimitiveTypeEnum::Bytes   => "bytes".to_string(),
                PrimitiveTypeEnum::String  => "string".to_string(),
            }
        }

        pub fn from_string(raw_type : &String) -> Option<PrimitiveTypeEnum> {
            match raw_type.as_ref() {
                "null"      => Some(PrimitiveTypeEnum::Null),
                "boolean"   => Some(PrimitiveTypeEnum::Boolean),
                "int"       => Some(PrimitiveTypeEnum::Int),
                "long"      => Some(PrimitiveTypeEnum::Long),
                "float"     => Some(PrimitiveTypeEnum::Float),
                "double"    => Some(PrimitiveTypeEnum::Double),
                "bytes"     => Some(PrimitiveTypeEnum::Bytes),
                "string"    => Some(PrimitiveTypeEnum::String),
                _           => None
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq)]
    pub struct Schema {
        #[serde(rename="type")]
        type_name: String,
        name: Option<String>,   // required for type = record|enum|fixed
        namespace: Option<String>,
        doc: Option<String>,
        aliases: Vec<String>,
        fields: Vec<Field>,
    }

    // For now, this really only supports Primitive Types.
    impl Schema {
        pub fn is_valid(&self) -> Result<(), &'static str> {
            //let record_type = "record".to_string();
            match self.type_name.as_ref() {
                "record"    => Ok(()),
                _           =>
                    match PrimitiveTypeEnum::from_string(&self.type_name) {
                        Some(..)    => Ok(()),
                        None        => Err("Not a valid simple type"),
                    },
            }
            
        }

        pub fn new(type_str: &str) -> Result<Schema, &'static str> {
            let tn = type_str.to_string();
            let schema = Schema {
                type_name: tn,
                name: None,
                namespace: None,
                doc: None,
                aliases: Vec::with_capacity(1),
                fields: Vec::with_capacity(1),
            };
            try!(schema.is_valid());
            Ok(schema)
        }
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq)]
    pub enum FieldType {
        Object,
        Name,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub enum SortOrder {
        Ascending,
        Descending,
        Ignore,
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq)]
    pub struct Field {
        name: String,
        doc: Option<String>, 
        #[serde(rename="type")]
        field_type: FieldType,
        default: Option<serde::json::Value>,    // Punt. 
        order: Option<SortOrder>,
        aliases: Option<Vec<String>>,
    }
} // end model mod
